import "pkg:/source/utils/TimeUtils.bs"
import "pkg:/source/services/SponsorBlock.bs"
import "pkg:/components/VideoPlayer/Video.bs"

function Init()
    SetupSponsorBlock()
    m.videoDetailsTask = m.top.findNode("VideoDetailsTask")
    ' busySpinner is our spinner, shown when loading the video details (like links, title, etc)
    m.busySpinner = m.top.findNode("BusySpinner")
    ' Once the Content is ready, the rokuBusySpinner shows up, which is loading the video feed
    m.rokuBusySpinner = FindChildNodeOfType(m.top, "BusySpinner")
    ' The label that shows the buffering percentage
    m.rokuBusySpinnerLabel = FindChildNodeOfType(m.rokuBusySpinner, "Label")
    SetupBusySpinner()
    m.busySpinner.visible = true
    m.busySpinner.control = "start"

    m.videoPlayingSuccess = false
    m.ignoreNextFinishedState = false

    m.top.trickPlayBar.filledBarBlendColor = "0xFF0000FF"
    m.top.bufferingBar.filledBarBlendColor = "0xFF0000FF"
    m.top.retrievingBar.filledBarBlendColor = "0xFF0000FF"

    m.top.observeField("control", "OnControlChange")
    m.top.observeField("videoId", "StartVideoDetailsTask")

    m.videoContainer = GetVideoContainer()
    m.videoContainer.observeFieldScoped("fullscreen", "OnFullScreenChange")
    OnFullScreenChange()

    m.top.ObserveField("state", "OnVideoPlayerStateChange")
end function

function OnkeyEvent(key as string, press as boolean) as boolean
    if press = false
        return false
    end if
    ' Unfortunately, a Video node cannot capture the "options" key (because, Roku...)
    ' https://community.roku.com/t5/Roku-Developer-Program/Bug-in-10-0-1-Options-key-is-not-being-consumed-by-onKeyEvent-when-Video-node-is-in-focus/m-p/709200/highlight/true#M49312
    ' Because of that, the button "down" is used to shrink the video for picture in picture mode
    if key = "down"
        if ToggleVideoPictureInPicture()
            return true
        end if
    end if
    if key = "back"
        CloseVideo()
        return true
    end if
    return false
end function

function OnControlChange()
    if m.top.control = "stop"
        m.sponsorBlockTask.control = "stop"
        m.videoDetailsTask.control = "stop"
    end if
end function

function StartVideoDetailsTask()
    m.videoDetailsTask.input = { videoId: m.top.videoId }
    m.videoDetailsTask.observeField("output", "OnVideoDetailsTaskResults")
    m.videoDetailsTask.control = "run"
end function

function OnVideoDetailsTaskResults() as void
    task = m.videoDetailsTask
    videoId = task.output.videoId
    metadata = task.output.metadata
    if videoId <> m.top.videoId
        return
    end if
    if metadata = invalid
        m.busySpinner.visible = false
        m.busySpinner.control = "stop"
        ShowDialog(`Failed to load video information for ${videoId}`, "Video load fail")
        CloseVideo()
        return
    end if

    contentNode = CreateObject("roSGNode", "ContentNode")
    contentNode.addFields({ metadata: metadata })

    if metadata.hlsUrl <> invalid
        contentNode.url = metadata.hlsUrl
    else if metadata.dashUrl <> invalid
        #if DASH_THUMBNAILS
            ' Redirect to our server so we can inject thumbnails (storyboards) into the DASH manifest
            contentNode.url = `http://${GetLocalIpAddress()}:8888/dash?v=${videoId}`
        #else
            contentNode.url = metadata.dashUrl
        #end if

    else
        stream = metadata.formatStreams[metadata.formatStreams.Count() - 1]
        itag = stream.itag
        ' Use an url relative to the host, so we can proxy(local=true) in case it fails
        contentNode.url = Invidious.GetVideoUrl(videoId, itag, false)
    end if

    contentNode.title = metadata.title
    contentNode.secondaryTitle = metadata.author
    SetCaptions(metadata, m.top, contentNode)
    m.busySpinner.visible = false
    m.busySpinner.control = "stop"
    m.top.content = contentNode
    m.top.control = "play"
end function

function FindChildNodeOfType(node as object, nodeType as string) as object
    if node.subtype() = nodeType
        return node
    end if

    childCount = node.getChildCount()
    children = node.getChildren(childCount, 0)
    for i = 0 to childCount - 1
        child = FindChildNodeOfType(children[i], nodeType)
        if child <> invalid
            return child
        end if
    end for

    return invalid
end function

function SetupBusySpinner()
    m.rokuBusySpinner.poster.width = 150
    m.rokuBusySpinner.poster.height = 150
    m.rokuBusySpinner.poster.uri = "pkg:/images/spinner.png"
    m.rokuBusySpinner.observeField("translation", "OnRokuSpinnerMoved")

    m.rokuBusySpinnerLabel.width = 150
    m.rokuBusySpinnerLabel.height = 150
    m.rokuBusySpinnerLabel.translation = [0, 0]
    m.rokuBusySpinnerLabel.observeField("translation", "OnRokuSpinnerLabelMoved")

    m.busySpinner.poster.width = 150
    m.busySpinner.poster.height = 150
    m.busySpinner.poster.uri = "pkg:/images/spinner.png"
end function

function OnRokuSpinnerMoved()
    currentTranslation = m.rokuBusySpinner.translation
    parentRect = m.top.boundingRect()
    centerx = (parentRect.width - m.rokuBusySpinner.poster.width) / 2
    centery = (parentRect.height - m.rokuBusySpinner.poster.height) / 2

    if currentTranslation[0] <> centerx or currentTranslation[1] <> centery
        m.rokuBusySpinner.translation = [centerx, centery]
    end if
end function

function OnRokuSpinnerLabelMoved()
    currentTranslation = m.rokuBusySpinnerLabel.translation
    if currentTranslation[0] <> 0 or currentTranslation[1] <> 0
        m.rokuBusySpinnerLabel.translation = [0, 0]
    end if
end function

function OnVideoPlayerStateChange() as void
    state = m.top.state

    ' If we successfully played the video, then any error that comes later is not due to a 403 (FORBIDDEN).
    ' This is to reduce false positives, as we do not want retry another link if the first link is working fine.
    if state = "playing"
        m.videoPlayingSuccess = true
    end if

    if state = "error"
        ' A hack to see if we could use the proxy here
        if m.videoPlayingSuccess <> true
            errorInfo = m.top.errorInfo
            ' http for stream format, mediaerror for DASH
            if errorInfo.category = "http" or errorInfo.category = "mediaerror"
                url = m.top.content.url
                if url.InStr("local=true") = -1
                    print(`Video ${url} failed to play. Trying a proxy (local=true)`)
                    if url.InStr("?") = -1
                        url += "?local=true"
                    else
                        url += "&local=true"
                    end if
                    m.top.content.url = url
                    ' This video errored, and is about to finish, so don't close the video yet
                    ' TODO: perhaps creating a second player is better?
                    m.ignoreNextFinishedState = true
                    m.top.control = "play"
                    return
                end if
            end if
        end if
    end if

    if state = "finished" and m.ignoreNextFinishedState = true
        m.ignoreNextFinishedState = false
        return
    end if

    if state = "finished"
        CloseVideo()
    end if

    if state = "error"
        errorInfo = m.top.errorInfo
        messageLines = [`VideoId: ${m.top.videoId}`]
        for each info in errorInfo
            messageLines.push(`${info}: ${errorInfo[info]}`)
        end for
        ShowDialog(messageLines, "Error playing video")
        CloseVideo()
    end if
end function

function OnFullScreenChange()
    margin = 20
    width = 1280
    height = 720
    if m.videoContainer.fullscreen
        m.top.translation = [0, 0]
        m.top.width = width
        m.top.height = height
    else
        small_width = width / 3
        small_height = height / 3
        x = width - small_width - margin
        y = height - small_height - margin

        m.top.translation = [x, y]
        m.top.width = small_width
        m.top.height = small_height
    end if

    m.top.enableUI = m.videoContainer.fullscreen
    PositionSpinner()
end function

function PositionSpinner()
    centerx = (m.top.width - m.busySpinner.poster.width) / 2
    centery = (m.top.height - m.busySpinner.poster.height) / 2
    m.busySpinner.translation = [centerx, centery]
end function
