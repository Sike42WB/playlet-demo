import "pkg:/components/Dialog/DialogUtils.bs"
import "pkg:/components/Services/ContinueWatching/ContinueWatchingUtils.bs"
import "pkg:/components/Services/Invidious/InvidiousToContentNode.bs"
import "pkg:/components/VideoPlayer/SponsorBlock.bs"
import "pkg:/components/VideoPlayer/VideoPlayerStyle.bs"
import "pkg:/components/VideoPlayer/VideoUtils.bs"
import "pkg:/source/AsyncTask/AsyncTask.bs"
import "pkg:/source/AsyncTask/Tasks.bs"
import "pkg:/source/utils/ErrorUtils.bs"
import "pkg:/source/utils/Logging.bs"
import "pkg:/source/utils/MathUtils.bs"

function Init()
    SetPlayerStyle()
    SetupAnimation()
    m.fullScreenHint = m.top.findNode("fullScreenHint")
    m.fullScreenHintLabel = m.top.findNode("fullScreenHintLabel")
    m.fullScreenHintTimer = m.top.findNode("fullScreenHintTimer")
    m.fullScreenHintTimer.ObserveField("fire", FuncName(OnFullScreenHintTimer))

    ' videoPlayingSuccess indicates if we started playing a video successfully
    ' We use it to detect if we should try another link for a video, or if another error
    ' occurred (such as a network error)
    m.videoPlayingSuccess = false
    ' ignoreNextFinishedState indicates if we should ignore the next finished state
    ' This is used to prevent the video from playing the next video when we are
    ' still trying to find a working stream url
    m.ignoreNextFinishedState = false
    ' asyncStopSemantics available since Roku OS 12.5
    ' It is set to true because stopping synchronously causes timeout and crash
    ' Usually we would need to wait for the video state to move to "stopping" then to "stopped"
    ' before considering the video node closed, and creating a new one.
    ' However, since we have a task to load video details, there should be enough time for the
    ' video node to close before we create a new one.
    if m.top.hasField("asyncStopSemantics")
        m.top.asyncStopSemantics = true
    end if

    m.videoPlayedToCompletion = false
    m.lastProgressTimestamp = 0
    m.lastSavedProgressTimestamp = 0
end function

function OnNodeReady()
    minRect = m.top.minRect
    rect = m.container.fullscreen ? m.top.maxRect : minRect

    m.top.width = rect.width
    m.top.height = rect.height
    m.top.translation = [rect.x, rect.y]

    m.fullScreenHint.width = minRect.width
    m.fullScreenHintLabel.width = minRect.width
    m.fullScreenHint.translation = [0, minRect.height - m.fullScreenHint.height]

    ' TODO:P2 show a loading spinner if video is loading minimized
    m.top.enableUI = m.container.fullscreen
    m.top.showFullScreenHint = not m.container.fullscreen

    m.container.observeFieldScoped("fullscreen", FuncName(OnFullScreenChange))
    m.top.ObserveField("state", FuncName(OnVideoPlayerStateChange))

    SponsorBlock.SetupSponsorBlock()
end function

function PlayWithContent(contentNode as object)
    videoContentNode = CreateObject("roSGNode", "ContentNode")

    if not StringUtils.IsNullOrEmpty(contentNode.videoId)
        videoContentNode.AddFields({ videoId: contentNode.videoId })
    end if
    if IsInt(contentNode.timestamp)
        videoContentNode.AddFields({ timestamp: contentNode.timestamp })
    end if
    if not StringUtils.IsNullOrEmpty(contentNode.title)
        videoContentNode.title = contentNode.title
    end if
    if not StringUtils.IsNullOrEmpty(contentNode.author)
        videoContentNode.secondaryTitle = contentNode.author
    end if
    if contentNode.progressNode <> invalid
        m.progressNode = contentNode.progressNode
    end if

    StartVideoContentTask(videoContentNode)
end function

function StartVideoContentTask(videoContentNode as object)
    if m.videoContentTask <> invalid
        m.videoContentTask.cancel = true
    end if

    MarkVideoWatched(videoContentNode)

    m.top.content = videoContentNode

    m.videoContentTask = AsyncTask.Start(Tasks.VideoContentTask, {
        content: videoContentNode
        invidious: m.top.invidious
        preferences: m.top.preferences
        playletServerPort: m.top.webServer.port
    }, OnVideoContentTaskResults)
end function

function OnVideoContentTaskResults(output as object) as void
    m.videoContentTask = invalid
    if output.cancelled
        return
    end if

    if not output.success or not output.result.success
        ' output.error for unhandled exception
        error = output.error
        if error = invalid
            ' output.result.error for network errors
            error = output.result.error
        end if
        error = ErrorUtils.Format(error)
        LogError(error)
        videoId = output.task.input.content.videoId
        message = `Failed to load video information for ${videoId}\n${error}`
        DialogUtils.ShowDialog(message, "Video load fail", true)
        ' TODO:P1 play next video in the queue after showing the error dialog
        VideoUtils.CloseVideo()
        return
    end if

    content = m.top.content
    metadata = content.metadata
    timestamp = ValidInt(content.timestamp)
    SponsorBlock.FetchSponsorBlock(metadata)

    m.top.control = "play"

    if timestamp = 0 and m.progressNode <> invalid and ValidInt(m.progressNode.timestamp) > 0
        timestamp = m.progressNode.timestamp
    end if

    if timestamp > 0
        m.top.seek = timestamp
    end if

    if m.progressNode <> invalid
        m.top.observeFieldScoped("position", FuncName(OnPositionChangeVideoProgress))
    end if
end function

function MarkVideoWatched(videoContentNode as object)
    if m.top.invidious.authToken <> invalid
        AsyncTask.Start(Tasks.MarkVideoWatchedTask, {
            videoId: videoContentNode.videoId
            invidious: m.top.invidious
        })
    end if

    if m.preferences["continue_watching.enabled"] = true
        if m.progressNode = invalid
            maxVideos = MathUtils.Min(ValidInt(m.preferences["continue_watching.max_videos"]), ContinueWatchingUtils.MAX_VIDEOS)
            m.progressNode = ContinueWatchingUtils.GetOrCreateNodeForVideo(m.continueWatching, videoContentNode.videoId, maxVideos)
        end if
        ContinueWatchingUtils.MarkWatchDate(m.progressNode)
        m.continueWatching.save = true
    else
        m.progressNode = invalid
    end if
end function

function Close(_unused as dynamic)
    HandleProgressBeforeClose()

    if m.videoContentTask <> invalid
        m.videoContentTask.cancel = true
        m.videoContentTask = invalid
    end if
    if m.sponsorBlockTask <> invalid
        m.sponsorBlockTask.cancel = true
        m.sponsorBlockTask = invalid
    end if

    parent = m.top.getParent()
    if parent <> invalid
        parent.RemoveChild(m.top)
    end if
    SponsorBlock.RemoveNotifcation(m.notifications)

    ' Stopping a video is slow and synchronous, and can lead to execution timeout crashes.
    try
        m.top.control = "stop"
    catch error
        DialogUtils.ShowDialog(ErrorUtils.Format(error), "Error closing video", true)
    end try

    m.top.content = invalid
end function

function HandleProgressBeforeClose() as void
    progressNode = m.progressNode
    if progressNode = invalid
        return
    end if
    m.progressNode = invalid

    if m.preferences["continue_watching.enabled"] <> true
        return
    end if

    if not m.videoPlayedToCompletion
        duration = progressNode.duration
        timestamp = progressNode.timestamp
        if duration > 0
            timeLeft = duration - timestamp
            percentageLeft = timeLeft / duration

            ' If we are less than 5% away from the end of the video, and the what's left is less than 20 seconds
            ' then we consider the video to be played to completion, to account for ending credits etc.
            if percentageLeft < 0.05 and timeLeft < 20
                m.videoPlayedToCompletion = true
            end if
        end if
    end if

    if not m.videoPlayedToCompletion
        m.continueWatching.save = true
        return
    end if

    content = m.top.content
    if content = invalid
        m.continueWatching.save = true
        return
    end if

    metadata = content.metadata
    if metadata = invalid
        m.continueWatching.save = true
        return
    end if

    videoId = metadata.videoId
    if StringUtils.IsNullOrEmpty(videoId)
        m.continueWatching.save = true
        return
    end if

    ContinueWatchingUtils.RemoveNodeForVideo(m.continueWatching, videoId)
    m.continueWatching.save = true
end function

function OnVideoPlayerStateChange() as void
    state = m.top.state
    content = m.top.content
    ' If we successfully played the video, then any error that comes later is not due to a 403 (FORBIDDEN).
    ' This is to reduce false positives, as we do not want retry another link if the first link is working fine.
    if state = "playing" and not m.videoPlayingSuccess
        LogInfo(`Now playing video ${content.url}`)
        m.videoPlayingSuccess = true
    end if

    if state = "error"
        errorInfo = m.top.errorInfo
        LogError(`Error playing video ${content.videoId}`, errorInfo)
        if m.videoPlayingSuccess <> true
            ' http for stream format, mediaerror for DASH
            if errorInfo.category = "http" or errorInfo.category = "mediaerror"
                currentUrl = content.url
                playletStreamUrls = content.playletStreamUrls
                playletStreamUrlIndex = content.playletStreamUrlIndex
                playletStreamUrlIndex++
                content.playletStreamUrlIndex = playletStreamUrlIndex
                if playletStreamUrlIndex < playletStreamUrls.Count()
                    nextUrl = playletStreamUrls[playletStreamUrlIndex]
                    LogError(`Stream ${currentUrl} failed to play. Trying next stream ${nextUrl}`)

                    content.url = nextUrl
                    ' This video errored, and is about to finish, so don't close the video yet
                    ' That's why we should ignore the next "finished" event
                    m.ignoreNextFinishedState = true
                    m.top.control = "play"

                    if ValidInt(content.timestamp) > 0
                        m.top.seek = content.timestamp
                    end if
                    return
                end if
            end if
        end if
    end if

    if state = "finished" and m.ignoreNextFinishedState = true
        m.ignoreNextFinishedState = false
        return
    end if

    if state = "finished"
        OnVideoFinished()
        return
    end if

    if state = "error"
        messageLines = []
        messageLines.push(`errorMsg: ${m.top.errorMsg}`)
        messageLines.push(`errorCode: ${m.top.errorCode}`)
        messageLines.push(`errorStr: ${m.top.errorStr}`)

        errorInfo = m.top.errorInfo
        if errorInfo <> invalid
            for each info in errorInfo
                messageLines.push(`${info}: ${errorInfo[info]}`)
            end for
        end if

        title = `Error playing video ${content.videoId}`
        LogError(title, messageLines)
        DialogUtils.ShowDialog(messageLines, title, true)
        ' TODO:P1 play next video in the queue after showing the error dialog
        VideoUtils.CloseVideo()
    end if
end function

function OnVideoFinished() as void
    m.videoPlayedToCompletion = true
    content = m.top.content
    if content = invalid
        m.playQueue@.watchedVideosClear()
        VideoUtils.CloseVideo()
        return
    end if

    metadata = content.metadata
    if metadata = invalid
        m.playQueue@.watchedVideosClear()
        VideoUtils.CloseVideo()
        return
    end if

    if not PlayNext(metadata.recommendedVideos)
        m.playQueue@.watchedVideosClear()
        VideoUtils.CloseVideo()
    end if
end function

function PlayNext(recommendedVideos as object) as boolean
    if m.playQueue@.PlayNextItem()
        return true
    end if

    return PlayNextRecommendedVideo(recommendedVideos)
end function

' TODO:P2 move this to the play queue
function PlayNextRecommendedVideo(recommendedVideos as object) as boolean
    if m.preferences["playback.autoplay"] <> true
        return false
    end if

    if recommendedVideos = invalid or recommendedVideos.Count() = 0
        return false
    end if

    for each metadata in recommendedVideos
        if metadata = invalid
            continue for
        end if
        videoId = metadata.videoId
        if videoId = invalid
            continue for
        end if
        if not m.playQueue@.watchedVideosContain(videoId)
            LogInfo(`Playing next recommended video (${videoId})`)
            instance = m.invidious@.GetCurrentInstance()
            node = InvidiousContent.ToVideoContentNode(invalid, metadata, instance, m.continueWatching.content)
            m.playQueue@.Play(node, -1)
            return true
        end if
    end for

    return false
end function

function OnkeyEvent(key as string, press as boolean) as boolean
    if press = false
        return false
    end if
    ' Unfortunately, a Video node cannot capture the "options" key (because, Roku...)
    ' https://community.roku.com/t5/Roku-Developer-Program/Bug-in-10-0-1-Options-key-is-not-being-consumed-by-onKeyEvent-when-Video-node-is-in-focus/m-p/709200/highlight/true#M49312
    ' Because of that, the button "down" is used to shrink the video for picture in picture mode
    if key = "down"
        if VideoUtils.ToggleVideoPictureInPicture()
            return true
        end if
    end if

    if key = "back"
        m.playQueue@.watchedVideosClear()
        VideoUtils.CloseVideo()
        return true
    end if
    return false
end function

function SetupAnimation()
    m.minimizeAnimation = m.top.findNode("minimizeAnimation")
    m.widthInterpolator = m.top.findNode("widthInterpolator")
    m.heightInterpolator = m.top.findNode("heightInterpolator")
    m.translationInterpolator = m.top.findNode("translationInterpolator")

    minRect = m.top.minRect
    maxRect = m.top.maxRect

    m.widthInterpolator.keyValue = [maxRect.width, (maxRect.width + minRect.width) / 2, minRect.width]
    m.heightInterpolator.keyValue = [maxRect.height, (maxRect.height + minRect.height) / 2, minRect.height]
    maxTranslation = [maxRect.x, maxRect.y]
    minTranslation = [minRect.x, minRect.y]
    midTranslation = [(maxRect.x + minRect.x) / 2, (maxRect.y + minRect.y) / 2]
    m.translationInterpolator.keyValue = [maxTranslation, midTranslation, minTranslation]
end function

function OnFullScreenChange()
    m.widthInterpolator.reverse = m.container.fullscreen
    m.heightInterpolator.reverse = m.container.fullscreen
    m.translationInterpolator.reverse = m.container.fullscreen

    m.minimizeAnimation.control = "start"

    m.top.enableUI = m.container.fullscreen
    m.top.showFullScreenHint = not m.container.fullscreen

    SponsorBlock.SetVisible(m.notifications, m.container.fullscreen)
end function

function OnShowFullScreenHint() as void
    m.fullScreenHintTimer.control = "stop"

    if m.container.fullscreen
        m.fullScreenHint.visible = false
        return
    end if

    if m.top.showFullScreenHint
        ' Take 1 second until the shrink animation finishes to show the hint
        m.fullScreenHintTimer.duration = 1
    else
        ' Wait 5 seconds then hide the hint
        m.fullScreenHintTimer.duration = 5
    end if

    m.fullScreenHintTimer.control = "start"
end function

function OnFullScreenHintTimer()
    showFullScreenHint = m.top.showFullScreenHint
    m.fullScreenHint.visible = showFullScreenHint
    if showFullScreenHint
        m.top.showFullScreenHint = false
    end if
end function

function OnPositionChangeVideoProgress() as void
    currentPosition = Int(m.top.position)
    ' Only update the progress node every 5 seconds.
    ' Avoid updating this too often because it makes the ContentNode
    ' one VideoRowCell nodes update.
    if Abs(m.lastProgressTimestamp - currentPosition) < 5
        return
    end if
    m.lastProgressTimestamp = currentPosition

    progressNode = m.progressNode
    if progressNode = invalid
        return
    end if

    progressNode.timestamp = currentPosition
    duration = m.top.duration
    if duration > 0
        progressNode.duration = Int(duration)
    end if

    ' Save the progress every 10 seconds
    if Abs(m.lastSavedProgressTimestamp - currentPosition) < 10
        return
    end if
    m.lastSavedProgressTimestamp = currentPosition

    m.continueWatching.save = true
end function
