// This plugin generates a file containing functions for type checking and type casting.
import { BeforeProvideFileEvent, CompilerPlugin } from "brighterscript";

const types = [
    { name: 'Bool', interface: 'ifBoolean', type: 'boolean', defaultValue: 'false' },
    { name: 'Int', interface: 'ifInt', type: 'integer', defaultValue: '0' },
    { name: 'Double', interface: 'ifDouble', type: 'double', defaultValue: '0#' },
    { name: 'String', interface: 'ifString', type: 'string', defaultValue: '""' },
    { name: 'Array', interface: 'ifArray', type: 'object', defaultValue: '[]' },
    { name: 'AssociativeArray', interface: 'ifAssociativeArray', type: 'object', defaultValue: '{}' },
    { name: 'ByteArray', interface: 'ifByteArray', type: null, defaultValue: null },
    { name: 'Function', interface: 'ifFunction', type: null, defaultValue: null },
    { name: 'Node', interface: 'ifSGNodeDict', type: null, defaultValue: null },
];

const generatedCodeHeader = `' The rest of this file is generated by the TypeGenPlugin`

const typesFilePath = 'source/utils/Types.bs';

const isTypeTemplate = (name: string, _interface: string) => {
    return `' Returns true if the given object is of type ${name}, false otherwise
function Is${name}(obj as dynamic) as boolean
    return obj <> invalid and GetInterface(obj, "${_interface}") <> invalid
end function`;
};

const validTypeTemplate = (name: string, type: string, _interface: string, defaultValue: string) => {
    return `' Returns the given object if it is of type ${name}, otherwise returns the default value \`${defaultValue}\`
function Valid${name}(obj as dynamic) as ${type}
    if obj <> invalid and GetInterface(obj, "${_interface}") <> invalid
        return obj
    else
        return ${defaultValue}
    end if
end function`;
}

export class TypeGenPlugin implements CompilerPlugin {
    public name = 'TypeGenPlugin';

    beforeProvideFile(event: BeforeProvideFileEvent) {
        if (!event.srcPath.endsWith(typesFilePath)) {
            return;
        }

        let content = event.data.value.toString();
        if (content.includes(generatedCodeHeader)) {
            return;
        }

        let generatedCode = `\n${generatedCodeHeader}\n\n`;

        types.forEach(type => {
            generatedCode += `${isTypeTemplate(type.name, type.interface)}\n`;
            if (type.type !== null && type.defaultValue !== null) {
                generatedCode += `${validTypeTemplate(type.name, type.type, type.interface, type.defaultValue)}\n`;
            }
        });

        content += generatedCode;

        const file = event.fileFactory.BrsFile({
            srcPath: event.srcPath,
            destPath: event.destPath,
        });
        file.fileContents = content;

        event.files.push(file);
    }
}

export default () => {
    return new TypeGenPlugin();
};
